# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Computes the convex minorant of a polygon.
#'
#' @return vector of the y-coordinates of the convex minorant
convexMinorant <- function(x, y) {
    .Call('rqIcm_convexMinorant', PACKAGE = 'rqIcm', x, y)
}

#' I can do my own documentation
rcpp_hello_world <- function() {
    .Call('rqIcm_rcpp_hello_world', PACKAGE = 'rqIcm')
}

rqIcmStep <- function(y, beta, blockLength, tau, lambda, method, c) {
    .Call('rqIcm_rqIcmStep', PACKAGE = 'rqIcm', y, beta, blockLength, tau, lambda, method, c)
}

rqIcm <- function(y, beta, blockLength, tau, lambda = 0, method = "1order") {
    .Call('rqIcm_rqIcm', PACKAGE = 'rqIcm', y, beta, blockLength, tau, lambda, method)
}

rqIcmRegional <- function(y, beta, blockLength, tau, lambda = 0, method = "1order") {
    .Call('rqIcm_rqIcmRegional', PACKAGE = 'rqIcm', y, beta, blockLength, tau, lambda, method)
}

#' Extends the parameter vector to the natural dimension
#' 
#' @param beta the parameter vector
#' @param blockLength the vector of blockLengths corresponding to each entry in beta
#' @return the extended parameter vector
completeBetaCpp <- function(beta, blockLength) {
    .Call('rqIcm_completeBetaCpp', PACKAGE = 'rqIcm', beta, blockLength)
}

#' Computes the smoothed objective criterion after Muggeo.etal2012
#' 
#' @param y the data
#' @param beta the parameter vector
#' @param blockLength the blocklength vector
#' @param tau the quantile 
rqSmooth <- function(y, beta, blockLength, tau, lambda = 0.0, method = "1order", c = 0.1) {
    .Call('rqIcm_rqSmooth', PACKAGE = 'rqIcm', y, beta, blockLength, tau, lambda, method, c)
}

#' Computes the smoothed objective criterion for multiple samples
#' 
#' @param y the data
#' @param beta the parameter vector
#' @param blockLength the blocklength vector
#' @param tau the quantile 
rqSmoothRegional <- function(y, beta, blockLength, tau, lambda = 0.0, method = "1order", c = 0.1) {
    .Call('rqIcm_rqSmoothRegional', PACKAGE = 'rqIcm', y, beta, blockLength, tau, lambda, method, c)
}

#' Computes the penalty term for a given parameter vector
#' 
#' @param beta parameter vector
#' @param lambda multiplicator
#' @param method (eiter "1order" = TV or "2order" = sum Second Derivative)
#' @return penalty
penaltyCpp <- function(beta, lambda, method = "1order") {
    .Call('rqIcm_penaltyCpp', PACKAGE = 'rqIcm', beta, lambda, method)
}

